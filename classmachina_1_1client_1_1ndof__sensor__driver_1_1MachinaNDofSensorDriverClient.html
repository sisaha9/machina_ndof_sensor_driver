<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Siddharth Saha&#39;s NDoF Sensor Driver for Machina Labs: machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Siddharth Saha&#39;s NDoF Sensor Driver for Machina Labs
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
   <div id="projectbrief">ROS 2 Driver for Machina Labs&#39; NDoF Sensor</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemachina.html">machina</a></li><li class="navelem"><a class="el" href="namespacemachina_1_1client.html">client</a></li><li class="navelem"><a class="el" href="namespacemachina_1_1client_1_1ndof__sensor__driver.html">ndof_sensor_driver</a></li><li class="navelem"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html">MachinaNDofSensorDriverClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to handle the client side of the Machina NDof Sensor Driver.  
 <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="machina__ndof__sensor__driver__client_8hpp_source.html">machina_ndof_sensor_driver_client.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d06a7df0efc708f8fefce7b302ba774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4d06a7df0efc708f8fefce7b302ba774">MachinaNDofSensorDriverClient</a> (rclcpp_lifecycle::LifecycleNode *node, uint64_t idx, uint64_t collection_interval, uint64_t service_timeout_interval, uint64_t max_service_connection_attempts)</td></tr>
<tr class="memdesc:a4d06a7df0efc708f8fefce7b302ba774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html" title="Class to handle the client side of the Machina NDof Sensor Driver.">MachinaNDofSensorDriverClient</a> object.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4d06a7df0efc708f8fefce7b302ba774">More...</a><br /></td></tr>
<tr class="separator:a4d06a7df0efc708f8fefce7b302ba774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64014a27ff5347f66d44e4b3590e09e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ae64014a27ff5347f66d44e4b3590e09e">~MachinaNDofSensorDriverClient</a> ()=default</td></tr>
<tr class="memdesc:ae64014a27ff5347f66d44e4b3590e09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html" title="Class to handle the client side of the Machina NDof Sensor Driver.">MachinaNDofSensorDriverClient</a> object.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ae64014a27ff5347f66d44e4b3590e09e">More...</a><br /></td></tr>
<tr class="separator:ae64014a27ff5347f66d44e4b3590e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a99f124d7abecd283e059cc8e7240c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a11a99f124d7abecd283e059cc8e7240c">FillSensorOutput</a> (machina_ndof_sensor_driver_msgs::msg::JointSensorOutput &amp;msg)</td></tr>
<tr class="memdesc:a11a99f124d7abecd283e059cc8e7240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the sensor output message with the latest sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a11a99f124d7abecd283e059cc8e7240c">More...</a><br /></td></tr>
<tr class="separator:a11a99f124d7abecd283e059cc8e7240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0822e5ba63b19588cd01eb33b222b850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a0822e5ba63b19588cd01eb33b222b850">StartReadingSensor</a> ()</td></tr>
<tr class="memdesc:a0822e5ba63b19588cd01eb33b222b850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread to continuously request sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a0822e5ba63b19588cd01eb33b222b850">More...</a><br /></td></tr>
<tr class="separator:a0822e5ba63b19588cd01eb33b222b850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe26951b5322cd07edede3fe582d3a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#abe26951b5322cd07edede3fe582d3a13">StopReadingSensor</a> ()</td></tr>
<tr class="memdesc:abe26951b5322cd07edede3fe582d3a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread to continuously request sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#abe26951b5322cd07edede3fe582d3a13">More...</a><br /></td></tr>
<tr class="separator:abe26951b5322cd07edede3fe582d3a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5ed265394f5994d1755bab6011e88898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5ed265394f5994d1755bab6011e88898">ReadSensorDataContinuously</a> ()</td></tr>
<tr class="memdesc:a5ed265394f5994d1755bab6011e88898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read sensor data continuously.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5ed265394f5994d1755bab6011e88898">More...</a><br /></td></tr>
<tr class="separator:a5ed265394f5994d1755bab6011e88898"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a00f827e7a27203ad224a0fbad403a5ea"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a></td></tr>
<tr class="memdesc:a00f827e7a27203ad224a0fbad403a5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the sensor. Used to identify which index to fill in the JointSensorOutput message.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">More...</a><br /></td></tr>
<tr class="separator:a00f827e7a27203ad224a0fbad403a5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deeb9a735bc52117af985ad7f7b182b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5deeb9a735bc52117af985ad7f7b182b">collection_interval_</a></td></tr>
<tr class="memdesc:a5deeb9a735bc52117af985ad7f7b182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval at which to request data from the driver.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5deeb9a735bc52117af985ad7f7b182b">More...</a><br /></td></tr>
<tr class="separator:a5deeb9a735bc52117af985ad7f7b182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12897150a2f05993ba1716a7a5486849"><td class="memItemLeft" align="right" valign="top">rclcpp::CallbackGroup::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a12897150a2f05993ba1716a7a5486849">client_callback_group_</a></td></tr>
<tr class="memdesc:a12897150a2f05993ba1716a7a5486849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback group for the client. Used to run the client callbacks in parallel with other callbacks on the executor.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a12897150a2f05993ba1716a7a5486849">More...</a><br /></td></tr>
<tr class="separator:a12897150a2f05993ba1716a7a5486849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727bd97f005488e78fded71cfcc7b8fd"><td class="memItemLeft" align="right" valign="top">rclcpp::Client&lt; machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData &gt;::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">sensor_data_client_</a></td></tr>
<tr class="memdesc:a727bd97f005488e78fded71cfcc7b8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client to request sensor data from the driver.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">More...</a><br /></td></tr>
<tr class="separator:a727bd97f005488e78fded71cfcc7b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac252ad50fa01ebc5745558b603593728"><td class="memItemLeft" align="right" valign="top">machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData::Request::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ac252ad50fa01ebc5745558b603593728">empty_request_</a></td></tr>
<tr class="memdesc:ac252ad50fa01ebc5745558b603593728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty request to send to the driver to request sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ac252ad50fa01ebc5745558b603593728">More...</a><br /></td></tr>
<tr class="separator:ac252ad50fa01ebc5745558b603593728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2671c14255e99e37c4c7c43163bc82"><td class="memItemLeft" align="right" valign="top">std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a3d2671c14255e99e37c4c7c43163bc82">latest_sensor_data_mutex_</a></td></tr>
<tr class="separator:a3d2671c14255e99e37c4c7c43163bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2db4a1ff0bd47ac6d84801653ed7640"><td class="memItemLeft" align="right" valign="top">machina_ndof_sensor_driver_msgs::msg::SensorOutput&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ad2db4a1ff0bd47ac6d84801653ed7640">latest_sensor_data_</a></td></tr>
<tr class="memdesc:ad2db4a1ff0bd47ac6d84801653ed7640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latest sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ad2db4a1ff0bd47ac6d84801653ed7640">More...</a><br /></td></tr>
<tr class="separator:ad2db4a1ff0bd47ac6d84801653ed7640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55c539a9c59c08f746edc52b92f5f4"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4f55c539a9c59c08f746edc52b92f5f4">sensor_data_thread_</a></td></tr>
<tr class="memdesc:a4f55c539a9c59c08f746edc52b92f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread to continuously request sensor data.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4f55c539a9c59c08f746edc52b92f5f4">More...</a><br /></td></tr>
<tr class="separator:a4f55c539a9c59c08f746edc52b92f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad0d1aac110f95738efd661cd937271"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">sensor_data_thread_running_</a> {false}</td></tr>
<tr class="memdesc:aaad0d1aac110f95738efd661cd937271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic to check if the sensor data thread is running.  <a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">More...</a><br /></td></tr>
<tr class="separator:aaad0d1aac110f95738efd661cd937271"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to handle the client side of the Machina NDof Sensor Driver. </p>
<p>This class provides an interface to the Machina NDof Sensor Driver to request sensor data and store it for further processing.</p>
<p>The <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClientNode.html">MachinaNDofSensorDriverClientNode</a> class spawns multiple instances of this class to handle multiple sensors.</p>
<p>The class uses a client to request one sensor's data from the driver and stores it. The data is then sent to the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClientNode.html">MachinaNDofSensorDriverClientNode</a> via the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a11a99f124d7abecd283e059cc8e7240c">FillSensorOutput</a> method.</p>
<p>A thread is spawned to continuously request data from the driver at a specified interval. Since this is concurrent with the main thread, we have defined 2 modes of operation:</p><ul>
<li>Lock-free using TACO from iceoryx (<a href="https://iceoryx.io/latest/advanced/iceoryx_hoofs/#concurrent">https://iceoryx.io/latest/advanced/iceoryx_hoofs/#concurrent</a>)</li>
<li>Using shared_mutex You can toggle between these modes by setting -DENABLE_LOCKFREE to ON/OFF ON for lock-free and OFF for shared_mutex. More experiments and data needs to be collected but right now TACO enables a significant speedup but it blocks access to the data often at high frequencies. Thinking of swapping to a 2 element container in the future so that the producer can always write to the 2nd element. If the 2nd element is being written to (can use atomic to check) then the consumer can read from the 1st element. This way we can avoid blocking. This is a future update.</li>
</ul>
<p>A future update to be made here is to use TypeAdapters to reduce the number of memory copies. If we have 2 nodes in the same container and use type adapters, we could get the data, send it in the exact same format to the other node and it can use it directly. This would be a zero copy</p>
<p>Additionally, unlike MachinaNDofSensorDriverServiceNode, this class and <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClientNode.html">MachinaNDofSensorDriverClientNode</a> have multiple callbacks sent to the ROS 2 executor. Hence, a simple StaticSingleThreadedExecutor (defined in the CMake of the MachinaNDofSensorDriverServiceNode) won't work here if we want to hit high frequencies. We use a MultiThreadedExecutor (defined in the CMake) and set a new callback group here so that the executor runs at least the callbacks defined here in parallel with other callbacks on the executor. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4d06a7df0efc708f8fefce7b302ba774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d06a7df0efc708f8fefce7b302ba774">&#9670;&nbsp;</a></span>MachinaNDofSensorDriverClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::MachinaNDofSensorDriverClient </td>
          <td>(</td>
          <td class="paramtype">rclcpp_lifecycle::LifecycleNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>collection_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>service_timeout_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_service_connection_attempts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html" title="Class to handle the client side of the Machina NDof Sensor Driver.">MachinaNDofSensorDriverClient</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the lifecycle node for the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClientNode.html">MachinaNDofSensorDriverClientNode</a> </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the sensor. Used to identify which index to fill in the JointSensorOutput message </td></tr>
    <tr><td class="paramname">collection_interval</td><td>Interval at which to request data from the driver </td></tr>
    <tr><td class="paramname">service_timeout_interval</td><td>Timeout interval for the service during initial connection </td></tr>
    <tr><td class="paramname">max_service_connection_attempts</td><td>Maximum number of attempts to connect to the service before throwing an error during initial connection </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    : <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a>(idx),</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5deeb9a735bc52117af985ad7f7b182b">collection_interval_</a>(collection_interval),</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a12897150a2f05993ba1716a7a5486849">client_callback_group_</a>(node-&gt;create_callback_group(</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;          rclcpp::CallbackGroupType::MutuallyExclusive)),</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">sensor_data_client_</a>(</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;          node-&gt;create_client&lt;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;              machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData&gt;(</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;              <span class="stringliteral">&quot;get_latest_sensor_data_&quot;</span> + std::to_string(idx),</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;              rclcpp::ServicesQoS(), <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a12897150a2f05993ba1716a7a5486849">client_callback_group_</a>)),</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ac252ad50fa01ebc5745558b603593728">empty_request_</a>(std::make_shared&lt;machina_ndof_sensor_driver_msgs::srv::</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                          GetLatestSensorData::Request&gt;())</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#ifdef ENABLE_LOCKFREE</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      ,</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      sensor_data_taco_(iox::concurrent::TACOMode::DenyDataFromSameContext)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="comment">// Wait for service to be available</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  uint64_t attempts = 0;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordflow">while</span> (!<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">sensor_data_client_</a>-&gt;wait_for_service(</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      std::chrono::nanoseconds(service_timeout_interval))) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for service at index &quot;</span> &lt;&lt; std::to_string(idx)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;              &lt;&lt; std::endl;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    attempts++;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// If service is not available after max attempts, throw an error</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">if</span> (attempts &gt;= max_service_connection_attempts) {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;      <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Service not available at index &quot;</span> +</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                               std::to_string(idx));</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a00f827e7a27203ad224a0fbad403a5ea"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::index_</a></div><div class="ttdeci">uint64_t index_</div><div class="ttdoc">Index of the sensor. Used to identify which index to fill in the JointSensorOutput message.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:149</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a12897150a2f05993ba1716a7a5486849"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a12897150a2f05993ba1716a7a5486849">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::client_callback_group_</a></div><div class="ttdeci">rclcpp::CallbackGroup::SharedPtr client_callback_group_</div><div class="ttdoc">Callback group for the client. Used to run the client callbacks in parallel with other callbacks on t...</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:158</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a5deeb9a735bc52117af985ad7f7b182b"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5deeb9a735bc52117af985ad7f7b182b">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::collection_interval_</a></div><div class="ttdeci">uint64_t collection_interval_</div><div class="ttdoc">Interval at which to request data from the driver.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:153</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a727bd97f005488e78fded71cfcc7b8fd"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_client_</a></div><div class="ttdeci">rclcpp::Client&lt; machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData &gt;::SharedPtr sensor_data_client_</div><div class="ttdoc">Client to request sensor data from the driver.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:163</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_ac252ad50fa01ebc5745558b603593728"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ac252ad50fa01ebc5745558b603593728">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::empty_request_</a></div><div class="ttdeci">machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData::Request::SharedPtr empty_request_</div><div class="ttdoc">Empty request to send to the driver to request sensor data.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:168</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae64014a27ff5347f66d44e4b3590e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64014a27ff5347f66d44e4b3590e09e">&#9670;&nbsp;</a></span>~MachinaNDofSensorDriverClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::~MachinaNDofSensorDriverClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html" title="Class to handle the client side of the Machina NDof Sensor Driver.">MachinaNDofSensorDriverClient</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11a99f124d7abecd283e059cc8e7240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a99f124d7abecd283e059cc8e7240c">&#9670;&nbsp;</a></span>FillSensorOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::FillSensorOutput </td>
          <td>(</td>
          <td class="paramtype">machina_ndof_sensor_driver_msgs::msg::JointSensorOutput &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the sensor output message with the latest sensor data. </p>
<p>This method is used by the <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClientNode.html">MachinaNDofSensorDriverClientNode</a> to fill the sensor output message with the latest sensor data. The message is then published to the ROS 2 network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Reference to the sensor output message to be filled </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                                              {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// Check if the index is within the range of the vector</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a> &gt;= msg.sensors.size()) {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    std::cerr &lt;&lt; <span class="stringliteral">&quot;Joint Sensor Output Vector not preallocated correctly&quot;</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;              &lt;&lt; std::endl;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// Check if the sensor data thread is running</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">sensor_data_thread_running_</a>.load()) {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    std::cerr &lt;&lt; <span class="stringliteral">&quot;Sensor data not being collected. Likely in deactivated state&quot;</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;              &lt;&lt; std::endl;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor">#ifndef ENABLE_LOCKFREE</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// If we are not using lockfree, we need to share lock the mutex to access the</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// latest sensor data. If we haven&#39;t received any sensor data yet, this</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// will just be empty data</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a3d2671c14255e99e37c4c7c43163bc82">latest_sensor_data_mutex_</a>.lock_shared();</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  msg.sensors.at(<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a>) = <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ad2db4a1ff0bd47ac6d84801653ed7640">latest_sensor_data_</a>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a3d2671c14255e99e37c4c7c43163bc82">latest_sensor_data_mutex_</a>.unlock_shared();</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="comment">// If we are using lockfree, we can just take the sensor data from the TACO</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="comment">// TACO can check if it is safe to take the data and if any data is available</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keyword">auto</span> ret_val = sensor_data_taco_.take(ThreadContext::Consumer);</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordflow">if</span> (ret_val.has_value()) {</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    msg.sensors.at(<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a>) = *ret_val;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to get sensor data from TACO: &quot;</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;              &lt;&lt; std::to_string(<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a00f827e7a27203ad224a0fbad403a5ea">index_</a>) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a3d2671c14255e99e37c4c7c43163bc82"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a3d2671c14255e99e37c4c7c43163bc82">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::latest_sensor_data_mutex_</a></div><div class="ttdeci">std::shared_mutex latest_sensor_data_mutex_</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:187</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_aaad0d1aac110f95738efd661cd937271"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_thread_running_</a></div><div class="ttdeci">std::atomic&lt; bool &gt; sensor_data_thread_running_</div><div class="ttdoc">Atomic to check if the sensor data thread is running.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:206</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_ad2db4a1ff0bd47ac6d84801653ed7640"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ad2db4a1ff0bd47ac6d84801653ed7640">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::latest_sensor_data_</a></div><div class="ttdeci">machina_ndof_sensor_driver_msgs::msg::SensorOutput latest_sensor_data_</div><div class="ttdoc">Latest sensor data.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:194</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ed265394f5994d1755bab6011e88898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed265394f5994d1755bab6011e88898">&#9670;&nbsp;</a></span>ReadSensorDataContinuously()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::ReadSensorDataContinuously </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read sensor data continuously. </p>
<p>This method is called by the sensor data thread to continuously request sensor data from the driver at the specified interval </p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                                                               {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// Continuously request sensor data from the driver</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keywordtype">bool</span> can_send_request = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// Loop until the thread is running. We use a boolean atomic to check if the</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="comment">// thread should still be running. If we want to stop this thread we can</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="comment">// set the boolean to false and it will enable a clean shutdown of this thread</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">while</span> (<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">sensor_data_thread_running_</a>.load()) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">// If we can send a request, send a request to the driver</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keywordflow">if</span> (can_send_request) {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      <span class="comment">// Start the timer to measure the time it takes to get the sensor data</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      <span class="comment">// Set the boolean to false so we don&#39;t send another request until we get</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      <span class="comment">// the response</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      can_send_request = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;      <span class="comment">// Send the request to the driver</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;      <span class="comment">// Async handler to not block the thread while waiting for the response</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      <span class="keyword">auto</span> future_result = <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a727bd97f005488e78fded71cfcc7b8fd">sensor_data_client_</a>-&gt;async_send_request(</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;          <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ac252ad50fa01ebc5745558b603593728">empty_request_</a>,</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;          [<span class="keyword">this</span>, &amp;start_time, &amp;can_send_request](</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;              rclcpp::Client&lt;machina_ndof_sensor_driver_msgs::srv::</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                                 GetLatestSensorData&gt;::SharedFuture future) {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            <span class="comment">// Get the sensor data from the future</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="keyword">auto</span> sensor_data = future.get();</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            <span class="comment">// If the sensor data is filled, store it in the class member</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            <span class="comment">// variable</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordflow">if</span> (sensor_data-&gt;sensor_data_filled) {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;#ifndef ENABLE_LOCKFREE</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;              <span class="comment">// If we are not using lockfree, we need to lock the mutex to</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;              <span class="comment">// store the sensor data</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;              latest_sensor_data_mutex_.lock();</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;              latest_sensor_data_ = sensor_data-&gt;sensor;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;              latest_sensor_data_mutex_.unlock();</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;#else</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;              <span class="comment">// If we are using lockfree, we can just store the sensor data in</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;              <span class="comment">// the TACO</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;              sensor_data_taco_.store(sensor_data-&gt;sensor,</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                                      ThreadContext::Producer);</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;#endif</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;              <span class="comment">// If the sensor data is not filled, print an error. This happens</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;              <span class="comment">// often when the service is using TACO and the data is not</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;              <span class="comment">// safe to take</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;              std::cerr &lt;&lt; <span class="stringliteral">&quot;Sensor data not filled in index &quot;</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                        &lt;&lt; std::to_string(index_) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="comment">// End the timer to measure the time it takes to get the sensor data</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            int64_t dur = std::max(</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(0),</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                    std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                        end_time - start_time)</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                        .count()));</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="comment">// Sleep for the remaining time to get the sensor data at the</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="comment">// specified interval</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="keyword">auto</span> sleep_time =</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                std::max(<span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(0),</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                         <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5deeb9a735bc52117af985ad7f7b182b">collection_interval_</a> - dur));</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            std::this_thread::sleep_for(std::chrono::nanoseconds(sleep_time));</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="comment">// Set the boolean to true so we can send another request</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            can_send_request = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;          });</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0822e5ba63b19588cd01eb33b222b850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0822e5ba63b19588cd01eb33b222b850">&#9670;&nbsp;</a></span>StartReadingSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::StartReadingSensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the thread to continuously request sensor data. </p>
<p>This method starts the thread to continuously request sensor data from the driver at the specified interval. The data is then stored for further processing. </p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                                                       {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="comment">// Start the sensor data thread</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">sensor_data_thread_running_</a>.store(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4f55c539a9c59c08f746edc52b92f5f4">sensor_data_thread_</a> = std::thread(</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      &amp;<a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5ed265394f5994d1755bab6011e88898">MachinaNDofSensorDriverClient::ReadSensorDataContinuously</a>, <span class="keyword">this</span>);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;}</div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a4f55c539a9c59c08f746edc52b92f5f4"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4f55c539a9c59c08f746edc52b92f5f4">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_thread_</a></div><div class="ttdeci">std::thread sensor_data_thread_</div><div class="ttdoc">Thread to continuously request sensor data.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.hpp:199</div></div>
<div class="ttc" id="aclassmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient_html_a5ed265394f5994d1755bab6011e88898"><div class="ttname"><a href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a5ed265394f5994d1755bab6011e88898">machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::ReadSensorDataContinuously</a></div><div class="ttdeci">void ReadSensorDataContinuously()</div><div class="ttdoc">Read sensor data continuously.</div><div class="ttdef"><b>Definition:</b> machina_ndof_sensor_driver_client.cpp:116</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abe26951b5322cd07edede3fe582d3a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe26951b5322cd07edede3fe582d3a13">&#9670;&nbsp;</a></span>StopReadingSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::StopReadingSensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the thread to continuously request sensor data. </p>
<p>This method stops the thread to continuously request sensor data from the driver at the specified interval. </p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                                                      {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// Stop the sensor data thread</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#aaad0d1aac110f95738efd661cd937271">sensor_data_thread_running_</a>.store(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <a class="code" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#a4f55c539a9c59c08f746edc52b92f5f4">sensor_data_thread_</a>.join();</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a12897150a2f05993ba1716a7a5486849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12897150a2f05993ba1716a7a5486849">&#9670;&nbsp;</a></span>client_callback_group_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::CallbackGroup::SharedPtr machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::client_callback_group_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback group for the client. Used to run the client callbacks in parallel with other callbacks on the executor. </p>

</div>
</div>
<a id="a5deeb9a735bc52117af985ad7f7b182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deeb9a735bc52117af985ad7f7b182b">&#9670;&nbsp;</a></span>collection_interval_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::collection_interval_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interval at which to request data from the driver. </p>

</div>
</div>
<a id="ac252ad50fa01ebc5745558b603593728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac252ad50fa01ebc5745558b603593728">&#9670;&nbsp;</a></span>empty_request_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData::Request::SharedPtr machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::empty_request_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty request to send to the driver to request sensor data. </p>

</div>
</div>
<a id="a00f827e7a27203ad224a0fbad403a5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f827e7a27203ad224a0fbad403a5ea">&#9670;&nbsp;</a></span>index_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::index_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the sensor. Used to identify which index to fill in the JointSensorOutput message. </p>

</div>
</div>
<a id="ad2db4a1ff0bd47ac6d84801653ed7640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2db4a1ff0bd47ac6d84801653ed7640">&#9670;&nbsp;</a></span>latest_sensor_data_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">machina_ndof_sensor_driver_msgs::msg::SensorOutput machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::latest_sensor_data_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Latest sensor data. </p>
<p>If we are not using lock-free, we need a class member variable to store the latest sensor data and exchange b/w threads </p>

</div>
</div>
<a id="a3d2671c14255e99e37c4c7c43163bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2671c14255e99e37c4c7c43163bc82">&#9670;&nbsp;</a></span>latest_sensor_data_mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_mutex machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::latest_sensor_data_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> @brief Shared Mutex to protect the sensor data

 If we are not using lock-free, we use a shared_mutex to protect the
</pre><p> <a class="el" href="classmachina_1_1client_1_1ndof__sensor__driver_1_1MachinaNDofSensorDriverClient.html#ad2db4a1ff0bd47ac6d84801653ed7640">latest_sensor_data_</a> variable </p>

</div>
</div>
<a id="a727bd97f005488e78fded71cfcc7b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727bd97f005488e78fded71cfcc7b8fd">&#9670;&nbsp;</a></span>sensor_data_client_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rclcpp::Client&lt;machina_ndof_sensor_driver_msgs::srv::GetLatestSensorData&gt;:: SharedPtr machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_client_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Client to request sensor data from the driver. </p>

</div>
</div>
<a id="a4f55c539a9c59c08f746edc52b92f5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f55c539a9c59c08f746edc52b92f5f4">&#9670;&nbsp;</a></span>sensor_data_thread_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread to continuously request sensor data. </p>

</div>
</div>
<a id="aaad0d1aac110f95738efd661cd937271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad0d1aac110f95738efd661cd937271">&#9670;&nbsp;</a></span>sensor_data_thread_running_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; machina::client::ndof_sensor_driver::MachinaNDofSensorDriverClient::sensor_data_thread_running_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic to check if the sensor data thread is running. </p>
<p>I don't use the LOCKFREE macro here since I think the atomic should always be faster for a boolean. We also assert that it is always lock-free </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/machina_ndof_sensor_driver_client/include/machina_ndof_sensor_driver_client/<a class="el" href="machina__ndof__sensor__driver__client_8hpp_source.html">machina_ndof_sensor_driver_client.hpp</a></li>
<li>src/machina_ndof_sensor_driver_client/src/<a class="el" href="machina__ndof__sensor__driver__client_8cpp.html">machina_ndof_sensor_driver_client.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
